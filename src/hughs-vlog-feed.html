<html>
  <link rel="import" href="hughs-vlog-feed__entry.html" />

  <template id="hughs-vlog-feed">
    <style>
      :host {
        display: block;
      }
    </style>
  </template>

  <script>//<![CDATA[
  (function () {
    "use strict";

    // http://stackoverflow.com/q/41408477/214325
    var ownerDocument = document.currentScript.ownerDocument;

    class HughsVlogFeed extends HTMLElement {
      
      // Remember to call the super method here
      constructor() {
        super();

        var feed = this;

        const $shadowRoot = feed.attachShadow({mode: 'open'});
        const $HughsVlogFeed = ownerDocument.querySelector( '#hughs-vlog-feed' );
        const $shadowContent = $HughsVlogFeed.content.cloneNode( true );

        feed.hvml = null;

        feed.loading = false;

        feed.ns = {
          "xml": "http://www.w3.org/XML/1998/namespace",
          "xhtml": "http://www.w3.org/1999/xhtml",
          "hvml": "http://vocab.nospoon.tv/ovml#",
          "xlink": "http://www.w3.org/1999/xlink"
        };

        feed.src = ( feed.getAttribute( 'src' ) || 'vlog.hvml' );

        feed.order = ( feed.getAttribute( 'order' ) || 'desc' ).toLowerCase();

        if ( feed.hasAttribute( 'limit' ) ) {
          feed.src += '?limit=' + feed.getAttribute( 'limit' );
        }

        feed.hvmlImported = new Promise(function HughsVlogFeedImportHvmlPromise( resolve, reject ) {
          if ( !feed.isLoaded() ) {
            var xhr = new XMLHttpRequest();

            xhr.open( 'GET', feed.src, true );
            xhr.setRequestHeader( 'Accept', 'application/hvml+xml;q=0.8,application/xml;q=0.6,text/xml;q=0.4' );
            
            xhr.onload = function xhrOnLoad( event ) {
              switch ( xhr.status ) {
                case 200:
                  switch ( feed.getAttribute( 'fetch-mode' )  ) {
                    case 'pedantic':
                      feed.hvml = xhr.responseXML;
                    break;

                    case 'lax':
                    /* falls through */
                    default:
                      // Doesn't work, probably because elements are already registered in a certain namespace by the time the attribute is removed
                      // xhr.responseXML.documentElement.removeAttribute( 'xmlns' );

                      // Stupid hack to work around the fact that null-prefix for default-namespaced elements doesn't work
                      feed.hvml = new DOMParser().parseFromString(
                        xhr.responseText.replace( 'xmlns="http://vocab.nospoon.tv/ovml#"', '' ),
                        'application/xml'
                      );
                  }

                  feed.loading = false;

                  resolve( feed.hvml );
                break;

                default:
                  feed.loading = false;

                  reject( Error( xhr.statusText ) );
              }
            };

            xhr.onerror = function xhrOnError( event ) {
              feed.loading = false;

              reject( Error( 'There was a network error.' ) );
            };

            xhr.send( '' );
          } // !feed.isLoaded()
        });

        $shadowRoot.appendChild( $shadowContent );
      } // constructor

      connectedCallback() {
        var feed = this;

        feed.setAttribute( 'role', 'article' );

        feed.hvmlImported.then(function ( response ) {
          return feed.select( '//video', feed.hvml );
        })
        .then(function ( nodes ) {
          var i;
          var entry;
          var node;

          switch ( feed.order ) {
            case 'asc':
              for ( i = 0; i < nodes.length; i++ ) {
                node = nodes[i];

                if ( node ) {
                  entry = document.createElement( 'hughs-vlog-feed__entry' );

                  if ( feed.hasAttribute( 'large' ) ) {
                    entry.setAttribute( 'large', 'large' );
                  }

                  if ( feed.hasAttribute( 'playable' ) ) {
                    entry.setAttribute( 'playable', 'playable' );
                  }

                  entry.data = node;

                  feed.shadowRoot.appendChild( entry );
                }
              }
            break;

            case 'desc':
            /* falls through */
            default:
              for ( i = nodes.length - 1; i >= 0; i-- ) {
                node = nodes[i];

                if ( node ) {
                  entry = document.createElement( 'hughs-vlog-feed__entry' );

                  if ( feed.hasAttribute( 'large' ) ) {
                    entry.setAttribute( 'large', 'large' );
                  }

                  if ( feed.hasAttribute( 'playable' ) ) {
                    entry.setAttribute( 'playable', 'playable' );
                  }
                  
                  entry.data = node;
                  
                  feed.shadowRoot.appendChild( entry );
                }
              }
            break;
          }
        });
      }

      select( xpath, refNode, xpathType ) {
        var feed = this;
        var evaluator = new XPathEvaluator();
        var promise = feed.hvmlImported.then(function ( response ) {
          if ( !xpath ) {
            throw 'No XPath provided';
          }

          if ( !refNode ) {
            throw 'No reference node provided';
          }

          var result;
          var nodes = [];
          var node;
          var i = 0;
          var snapshotLength;
          // response === feed.hvml
          
          // Automatic Namespace Resolution:
          // feed.nsResolver = feed.evaluator.createNSResolver( feed.hvml.documentElement );
          
          // Custom Namespace Resolution:
          var defaultNS = feed.hvml.documentElement.getAttribute( 'xmlns' ) || feed.ns.hvml;

          function nsResolver( prefix ) {
            return ( feed.ns[prefix] || defaultNS );
          }

          // xpathType = xpathType ||  XPathResult.ORDERED_NODE_ITERATOR_TYPE;
          // Better performance (https://www.nczonline.net/blog/2009/03/17/xpath-in-javascript-part-1/)
          xpathType = xpathType || XPathResult.ORDERED_NODE_SNAPSHOT_TYPE;

          result = evaluator.evaluate(
            xpath,
            refNode,
            nsResolver,
            xpathType,
            null
          );

          if ( result ) {
            switch ( xpathType ) {
              case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
                node = result.iterateNext();

                nodes.push( node );

                while( node ) {
                  node = result.iterateNext();
                  nodes.push( node );
                }
              break;

              case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
                for ( snapshotLength = result.snapshotLength; i < snapshotLength; ++i ) {
                  nodes.push( result.snapshotItem(i) );
                }
              break;

              // default:
            }
          }

          // resolve( result );
          return nodes;
        });

        return promise;
      }

      isLoaded() {
        return ( !this.loading && ( this.hvml !== null ) );
      }
    }

    window.customElements.define( 'hughs-vlog-feed', HughsVlogFeed );
  })();
  //]]></script>
</html>