<html>
  <link rel="import" href="hughs-vlog-feed__entry.html" />

  <template id="hughs-vlog-feed">
    <hughs-vlog-feed__entry></hughs-vlog-feed__entry>
  </template>

  <script>//<![CDATA[
  (function () {
    "use strict";

    // http://stackoverflow.com/q/41408477/214325
    var ownerDocument = document.currentScript.ownerDocument;

    class HughsVlogFeed extends HTMLElement {
      
      // Remember to call the super method here
      constructor() {
        super();

        var feed = this;

        const $shadowRoot = feed.attachShadow({mode: 'open'});
        const $HughsVlogFeed = ownerDocument.querySelector( '#hughs-vlog-feed' );
        const $shadowContent = $HughsVlogFeed.content.cloneNode( true );

        feed.ovml = null;
        feed.nsResolver = null;
        feed.evaluator = new XPathEvaluator();
        feed.ns = {
          "xml": "http://www.w3.org/XML/1998/namespace",
          "xhtml": "http://www.w3.org/1999/xhtml",
        };
        feed.loading = false;

        feed.src = feed.getAttribute( 'src' ) || 'vlog.ovml';

        feed.OVMLimported = new Promise(function HughsVlogFeedImportOVMLPromise( resolve, reject ) {
          if ( !feed.isLoaded() ) {
            var xhr = new XMLHttpRequest();

            xhr.open( 'GET', feed.src, true );
            xhr.setRequestHeader( 'Accept', 'application/ovml+xml;q=0.8,application/xml;q=0.6,text/xml;q=0.4' );
            
            xhr.onload = function xhrOnLoad( event ) {
              switch ( xhr.status ) {
                case 200:
                  switch ( feed.getAttribute( 'fetch-mode' )  ) {
                    case 'pedantic':
                      feed.ovml = xhr.responseXML;
                    break;

                    case 'lax':
                    default:
                      // Doesn't work, probably because elements are already registered in a certain namespace by the time the attribute is removed
                      // xhr.responseXML.documentElement.removeAttribute( 'xmlns' );

                      // Stupid hack to work around the fact that null-prefix for namespaced elements doesn't work
                      feed.ovml = new DOMParser().parseFromString(
                        xhr.responseText.replace( 'xmlns="http://vocab.nospoon.tv/ovml#"', '' ),
                        'application/xml'
                      );
                  }

                  feed.loading = false;

                  resolve( feed.ovml );
                break;

                default:
                  feed.loading = false;

                  reject( Error( xhr.statusText ) );
              }
            };

            xhr.onerror = function xhrOnError( event ) {
              feed.loading = false;

              reject( Error( 'There was a network error.' ) );
            };

            xhr.send( '' );
          } // !feed.isLoaded()
        });

        $shadowRoot.appendChild( $shadowContent );
      } // constructor

      connectedCallback() {
        var feed = this;

        feed.setAttribute( 'role', 'article' );
      }

      select( xpath, refNode, xpathType ) {
        var feed = this;

        var selectPromise = new Promise(function HughsVlogFeedSelectPromise( resolve, reject ) {
          feed.OVMLimported.then(function ( response ) {
            // response === feed.ovml
            feed.ns[''] = feed.ovml.documentElement.getAttribute( 'xmlns' );
            feed.ns.ovml = feed.ovml.documentElement.getAttribute( 'xmlns:ovml' );
            feed.ns.xlink = feed.ovml.documentElement.getAttribute( 'xmlns:xlink' );
            // feed.nsResolver = feed.evaluator.createNSResolver( feed.ovml.documentElement );
            
            // feed.ovml.documentElement.removeAttribute( 'xmlns' );

            function nsResolver( prefix ) {
              return ( feed.ns[prefix] || feed.ns.defaultNS );
            };

            console.log( feed.ns );

            xpath = xpath || '//video';
            refNode = refNode || feed.ovml;
            xpathType = xpathType || XPathResult.ORDERED_NODE_ITERATOR_TYPE;

            // console.log();
            // document.evaluate
            var node = feed.evaluator.evaluate(
              xpath,
              refNode,
              nsResolver,
              xpathType,
              null
            ).iterateNext();

            resolve( node );
          });
        });

        return selectPromise;
      }

      isLoaded() {
        var feed = this;

        return ( !feed.loading && ( feed.ovml !== null ) );
      }
    }

    window.customElements.define( 'hughs-vlog-feed', HughsVlogFeed );
  })();
  //]]></script>
</html>