<% include ../head.xml %>
    <link rel="import" href="hughs-vlog-feed__entry.html" />
  </head>
  <template id="hughs-vlog-feed">
    <style>
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
      }

      .hughs-vlog-feed-entry:first-of-type {
        width: 100%;
      }
    </style>
  </template>
  <script>//<![CDATA[
  (function () {
    "use strict";

    // http://stackoverflow.com/q/41408477/214325
    var ownerDocument = document.currentScript.ownerDocument;

    class HughsVlogFeed extends HTMLElement {
      static get observedAttributes() {
        return [ 'src', 'order', 'limit' ];
      }

      getSrc( src ) {
        return ( src || this.getAttribute( 'src' ) );
      }

      getOrder( order ) {
        return ( order || this.getAttribute( 'order' ) || 'desc' ).toLowerCase();
      }

      getLimit( limit ) {
        return ( limit || this.getAttribute( 'limit' ) );
      }

      attributeChangedCallback( attribute, oldValue, newValue ) {
        console.log( 'attribute changed:' );
        console.log( attribute, oldValue, newValue );

        switch ( attribute ) {
          case 'src':
            this.src = this.getSrc( newValue );
            this._importHvmlAndAppendEntries();
          break;

          case 'order':
            this.order = this.getOrder( newValue );
          break;

          case 'limit':
            this.limit = this.getLimit( newValue );
          break;
        }
      }

      importHvml() {
        var feed = this;

        this.hvmlImported = new Promise(
          // this.importHvmlPromise.bind( this )
          function importHvmlPromise( resolve, reject ) {
            if ( !feed.isLoaded() ) {
              if ( feed.hasOwnProperty( 'src' ) && feed.src ) {
                console.log( 'has feed src' );
                console.log( 'feed.src', feed.src );

                var xhr = new XMLHttpRequest();

                xhr.open( 'GET', feed.src, true );
                xhr.setRequestHeader( 'Accept', 'application/hvml+xml;q=0.8,application/xml;q=0.6,text/xml;q=0.4' );

                xhr.onload = function xhrOnLoad( event ) {
                  switch ( xhr.status ) {
                    case 200:
                      switch ( feed.getAttribute( 'fetch-mode' )  ) {
                        case 'pedantic':
                          feed.hvml = xhr.responseXML;
                        break;

                        case 'lax':
                        /* falls through */
                        default:
                          // Doesn't work, probably because elements are already registered in a certain namespace by the time the attribute is removed
                          // xhr.responseXML.documentElement.removeAttribute( 'xmlns' );

                          // Stupid hack to work around the fact that null-prefix for default-namespaced elements doesn't work
                          feed.hvml = new DOMParser().parseFromString(
                            xhr.responseText.replace( 'xmlns="http://vocab.nospoon.tv/ovml#"', '' ),
                            'application/xml'
                          );
                      }

                      console.log( 'feed.hvml', feed.hvml );

                      feed.loading = false;

                      resolve( feed.hvml );
                    break;

                    default:
                      feed.loading = false;

                      reject( Error( xhr.statusText ) );
                  }
                };

                xhr.onerror = function xhrOnError( event ) {
                  feed.loading = false;

                  reject( Error( 'There was a network error.' ) );
                };

                xhr.send( '' );
              } else {
                console.log( 'no feed src' );
              }
            } // !feed.isLoaded()
          }
        );
      }

      // Remember to call the super method here
      constructor() {
        super();

        var feed = this;

        const $shadowRoot = feed.attachShadow({mode: 'open'});
        const $HughsVlogFeed = ownerDocument.querySelector( '#hughs-vlog-feed' );
        const $shadowContent = $HughsVlogFeed.content.cloneNode( true );

        feed.hvml = null;

        feed.loading = false;

        feed.ns = {
          "xml": "http://www.w3.org/XML/1998/namespace",
          "xhtml": "http://www.w3.org/1999/xhtml",
          "hvml": "http://vocab.nospoon.tv/ovml#",
          "xlink": "http://www.w3.org/1999/xlink"
        };

        feed.src = feed.getSrc();
        // console.log( 'feed.src', feed.src );

        feed.order = feed.getOrder();

        feed.limit = feed.getLimit();

        if ( feed.hasOwnProperty( 'src' ) && feed.src ) {
          feed.importHvml();
        }

        $shadowRoot.appendChild( $shadowContent );
      } // constructor

      connectedCallback() {
        var feed = this;

        feed.setAttribute( 'role', 'article' );

        if ( feed.hasOwnProperty( 'hvmlImported' ) ) {
          feed._appendEntries();
        }
      }

      _importHvmlAndAppendEntries() {
        this.importHvml();
        this._appendEntries();
      }

      _appendEntries() {
        console.log( '_appendEntries' );

        var feed = this;

        console.log( 'feed.hvmlImported', feed.hvmlImported );

        feed.hvmlImported.then(function selectHvmlVideoElements( response ) {
          console.log( 'selectHvmlVideoElements' );

          return feed.select( '//video', feed.hvml );
        })
        .then(function appendHtmlElements( nodes ) {
          console.log( 'appendHtmlElements' );

          var i;
          var entry;
          var node;

          switch ( feed.order ) {
            case 'desc':
              for ( i = 0; i < nodes.length; i++ ) {
                node = nodes[i];

                if ( node ) {
                  entry = document.createElement( 'hughs-vlog-feed__entry' );

                  if ( feed.hasAttribute( 'large' ) ) {
                    entry.setAttribute( 'large', 'large' );
                  }

                  if ( feed.hasAttribute( 'playable' ) ) {
                    entry.setAttribute( 'playable', 'playable' );
                  }

                  entry.data = node;

                  feed.shadowRoot.appendChild( entry );
                }
              }
            break;

            case 'asc':
            /* falls through */
            default:
              for ( i = nodes.length - 1; i >= 0; i-- ) {
                node = nodes[i];

                if ( node ) {
                  entry = document.createElement( 'hughs-vlog-feed__entry' );

                  if ( feed.hasAttribute( 'large' ) ) {
                    entry.setAttribute( 'large', 'large' );
                  }

                  if ( feed.hasAttribute( 'playable' ) ) {
                    entry.setAttribute( 'playable', 'playable' );
                  }

                  entry.data = node;

                  feed.shadowRoot.appendChild( entry );
                }
              }
            break;
          }
        });
      }

      select( xpath, refNode, xpathType ) {
        var feed = this;
        var evaluator = new XPathEvaluator();
        var promise = feed.hvmlImported.then(function ( response ) {
          if ( !xpath ) {
            throw 'No XPath provided';
          }

          if ( !refNode ) {
            throw 'No reference node provided';
          }

          var result;
          var nodes = [];
          var node;
          var i = 0;
          var snapshotLength;
          // response === feed.hvml

          // Automatic Namespace Resolution:
          // feed.nsResolver = feed.evaluator.createNSResolver( feed.hvml.documentElement );

          // Custom Namespace Resolution:
          var defaultNS = feed.hvml.documentElement.getAttribute( 'xmlns' ) || feed.ns.hvml;

          function nsResolver( prefix ) {
            return ( feed.ns[prefix] || defaultNS );
          }

          // xpathType = xpathType ||  XPathResult.ORDERED_NODE_ITERATOR_TYPE;
          // Better performance (https://www.nczonline.net/blog/2009/03/17/xpath-in-javascript-part-1/)
          xpathType = xpathType || XPathResult.ORDERED_NODE_SNAPSHOT_TYPE;

          result = evaluator.evaluate(
            xpath,
            refNode,
            nsResolver,
            xpathType,
            null
          );

          if ( result ) {
            switch ( xpathType ) {
              case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
                node = result.iterateNext();

                nodes.push( node );

                while( node ) {
                  node = result.iterateNext();
                  nodes.push( node );
                }
              break;

              case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
                for ( snapshotLength = result.snapshotLength; i < snapshotLength; ++i ) {
                  nodes.push( result.snapshotItem(i) );
                }
              break;

              // default:
            }
          }

          // resolve( result );
          return nodes;
        });

        return promise;
      }

      isLoaded() {
        return ( !this.loading && ( this.hvml !== null ) );
      }
    }

    window.customElements.define( 'hughs-vlog-feed', HughsVlogFeed );
  })();
  //]]></script>
</html>
