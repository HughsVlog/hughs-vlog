import { XMLNS } from './dom.js';

const HVMLAwareElement = ( superClass ) => {
  return class extends superClass {
    select( xpath, refNode, xpathType ) {
      // console.log( 'Called `select`' );

      var evaluator = new XPathEvaluator();
        if ( !xpath ) {
          throw 'No XPath provided';
        }

        if ( !refNode ) {
          if ( this.data ) {
            refNode = this.data;
          } else {
            throw 'No reference node provided, either as parameter `refNode` or instance property `this.data`';
          }
        }

        switch ( refNode.nodeType ) {
          case Node.ELEMENT_NODE: // 1
            // console.log( 'Element node' );
          break;

          case Node.TEXT_NODE: // 3
          case Node.PROCESSING_INSTRUCTION_NODE: // 7
          case Node.COMMENT_NODE: // 8
          break;

          case Node.DOCUMENT_NODE: // 9
            // console.log( 'Document node' );
          break;

          case Node.DOCUMENT_TYPE_NODE: // 10
          case Node.DOCUMENT_FRAGMENT_NODE: // 11
          break;
        }

        var result;
        var nodes = [];
        var node;
        var i = 0;
        // var snapshotLength;
        var defaultNS;

        // console.log( 'refNode', [refNode] );

        // Automatic Namespace Resolution:
        // XMLNSResolver = this.evaluator.createNSResolver( this.hvml.documentElement );

        // Custom Namespace Resolution:
        if ( 'namespaceURI' in refNode ) {
          defaultNS = refNode.namespaceURI;
        } else if ( ( 'hasAttribute' in refNode ) && refNode.hasAttribute( 'xmlns' ) ) {
          defaultNS = refNode.getAttribute( 'xmlns' );
        } else if ( ( 'documentElement' in refNode ) && refNode.documentElement.hasAttribute( 'xmlns' ) ) {
          defaultNS = refNode.documentElement.getAttribute( 'xmlns' );
        } else {
          // defaultNS = XMLNS.hvml;
          defaultNS = XMLNS.xhtml;
          // console.log( 'fallback' );
        }

        // HVML data doesn’t always come in correctly, i.e. if it was
        // blindly generated by JS that didn’t take namespacing into
        // account, which would then make it “XHTML” instead of true
        // HVML. So whatever we’ve determined the default namespace
        // to be based on the above heuristics, is what nsResolver
        // will have to point to for the `hvml` prefix. Otherwise,
        // XPath expressions will fail unnecessarily.
        XMLNS.hvml = defaultNS;

        // console.log( 'XMLNS', XMLNS );
        // console.log( 'defaultNS', defaultNS );

        function nsResolver( prefix ) {
          // We still need to use defaultNS here, just in case there
          // is a namespace with no prefix.
          return ( XMLNS[prefix] || defaultNS );
          // return XMLNS.xhtml;
        }

        // xpathType = xpathType ||  XPathResult.ORDERED_NODE_ITERATOR_TYPE;
        // Better performance (https://www.nczonline.net/blog/2009/03/17/xpath-in-javascript-part-1/)
        xpathType = xpathType || XPathResult.ORDERED_NODE_SNAPSHOT_TYPE;

        result = evaluator.evaluate(
          xpath,
          // '//xhtml:hvml',
          refNode,
          nsResolver,
          // XMLNS.xhtml,
          // null,
          xpathType,
          null
        );

        // console.log( 'XMLNS', XMLNS );
        // console.log( 'defaultNS', defaultNS );
        // console.log( 'nsResolver( \'hvml\' )', nsResolver( 'hvml' ) );
        // console.log( 'refNode.namespaceURI', refNode.namespaceURI );

        // console.log( 'result', result );

        if ( result ) {
          switch ( xpathType ) {
            case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
              // console.log( 'ordered node iterator' );
              node = result.iterateNext();
              nodes.push( node );

              while( node ) {
                node = result.iterateNext();
                nodes.push( node );
              }
            break;

            // eslint-disable-next-line
            case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
              let snapshotLength = result.snapshotLength;
              // console.log( 'ordered node snapshot' );

              if ( !snapshotLength ) {
                throw `XPath expression \`${xpath}\` didn’t match any nodes in \`${refNode.nodeName.toLowerCase()}\``;
              }

              for ( ; i < snapshotLength; ++i ) {
                nodes.push( result.snapshotItem(i) );
              }
            break;

            default:
              // console.log( 'default' );
          }
        }
        // else {
        //   console.log( 'Falsey result: ', result );
        // }

        return nodes;
    } // select

    giveChildrenUpForAdoption() {
      if ( this.shadowRoot && this.shadowRoot.children && this.shadowRoot.children.length ) {
        // console.log( 'Removing applicable children: ', this.shadowRoot.children );

        var children = this.shadowRoot.children;

        // for (let item of list)
        for ( let i = 0; i < children.length; i++ ) {
          let child = children[i];
          let nodeName = child.nodeName.toLowerCase();

          if ( !this._isTemplateChild( nodeName ) /*&& ( nodeName !== 'h2' )*/ ) {
            // console.log( `Removing ${nodeName}`, child )
            this.shadowRoot.removeChild( child );
          } else {
            // console.log( `Skipping ${nodeName}`, child );
          }
        }
      } else {
        // console.log( 'has no children' );
      }
    }

    _getFirstHvmlChild( children ) {
      // @todo: Deal with hvml not being the first child
      if ( children.length ) {
        for ( let i = 0; i < children.length; i++ ) {
          switch ( children[i].nodeName.toLowerCase() ) {
            case 'hvml':
            case 'video':
              return children[i];
            break;
          }
        }
      }

      return false;
    }

    _containsHvml( children ) {
      return !!this._getFirstHvmlChild( children );
    }

    _slotContainsHvml( slot ) {
      // @todo: Check if input is actually a slot.
      // Deferred for now because it’s usually redundant.
      // if ( slot && ( slot.nodeName.toLowerCase() === 'slot' ) ) {
      const assignedNodes = slot.assignedNodes();
      return this._containsHvml( assignedNodes );
      // }
      // return false;
    }

    // Plain node trees can’t be queried with XPath,
    // so we have to turn them into a legitimate Document object.
    _documentifyHvml( tempHvml ) {
      // Hack for edge case where a slotted <hvml> has no @xmlns:
      if ( tempHvml.namespaceURI === XMLNS.xhtml ) {
        console.log( '<hvml> is in the XHTML namespace; hvml: will be aliased' );
        XMLNS.hvml = XMLNS.xhtml;
      }

      // Document nodes are not allowed as children of Element nodes,
      // so this should always be true and we can skip checking it
      // if ( tempHvml.nodeType !== Node.DOCUMENT_NODE ) {
      var doc = document.implementation.createDocument( ( tempHvml.namespaceURI || XMLNS.hvml ), 'hvml', null );

      if ( tempHvml.hasAttributes() ) {
        // console.log( 'tempHvml has attributes' );
        let attributes = tempHvml.attributes;
        for ( let i = attributes.length - 1; i >= 0; --i ) {
          doc.documentElement.setAttribute( attributes[i].name, attributes[i].value );
        }
      }

      doc.documentElement.appendChild(
        tempHvml.children[0]
          // - Using cloneNode allows us to retain the light DOM.
          // - Omitting cloneNode will remove the HVML children from
          //   the light DOM and append them to the invisible this.hvml.
          //   If the light DOM was updated, this.hvml would have to be kept
          //   in-sync, and vice-versa.
          .cloneNode( true )
      );

      return doc;
    }

    _loadHvmlFromElementNode( hvml, resolve ) {
      this.hvml = this._documentifyHvml( hvml );
      this.loading = false;
      resolve( this.hvml );
    }

    _resolveHvml( resolve, reject ) {
      // console.log( 'Resolving HVML' );

      if ( !this.isLoaded() ) {
        // console.log( 'HVML not yet loaded' );

        if ( this.hasOwnProperty( 'src' ) && this.src ) {
          // console.log( 'Feed has src attribute' );

          // console.log( 'has feed src' );
          // console.log( 'this.src', this.src );
          var xhr = new XMLHttpRequest();

          xhr.open( 'GET', this.src, true );
          xhr.setRequestHeader( 'Accept', 'application/hvml+xml;q=0.8,application/xml;q=0.6,text/xml;q=0.4' );

          xhr.onload = ( event ) => {
            switch ( xhr.status ) {
              case 200:
                this.hvml = xhr.responseXML;
                this.loading = false;
                resolve( this.hvml );
              break;

              default:
                this.loading = false;
                reject( Error( xhr.statusText ) );
            }
          };

          xhr.onerror = ( event ) => {
            this.loading = false;
            reject( Error( 'There was a network error.' ) );
          };

          xhr.send( '' );
        // No src, check for slotted hvml child
        } else {
          // console.log( 'Feed has no src, check for slotted hvml child', this.shadowRoot );

          var slot = this.querySelector( 'slot' );

          if ( slot ) {
            // console.log( 'feed has slot; loading HVML if possible right now and setting up event listener' );

            let hvmlChild = this._getFirstHvmlChild( slot.assignedNodes() );

            if ( hvmlChild ) {
              this._loadHvmlFromElementNode( hvmlChild, resolve );
            }

            // Avoid race conditions:
            slot.addEventListener( 'slotchange', this.slotChanged.bind( this, resolve, reject ) );
          // No src or slotted hvml; test for direct children (e.g. in the case of the ShadyDOM polyfill)
          } else {
            let hvmlChild = this._getFirstHvmlChild( this.children );
            if ( hvmlChild ) {
              this.hvml = this._documentifyHvml( hvmlChild );
              this.loading = false;
              resolve( this.hvml );
            // No light DOM hvml children
            } else {
              let hvmlChild = this._getFirstHvmlChild( this.shadowRoot.children );
              if ( hvmlChild ) {
                this.hvml = this._documentifyHvml( hvmlChild );
                this.loading = false;
                resolve( this.hvml );
              // No shadow DOM hvml children
              } else {
                reject( `\`${this.nodeName.toLowerCase()}\`: No src, nor hvml children (slotted, direct, or shadow)` );
              }
            }
          } // if slot
        }
      // !this.isLoaded()
      } else {
        // console.log( 'HVML is alread loaded' );
        resolve( this.hvml );
      }
      // return this.hvml;
    } // _resolveHvml

    importHvml() {
      // console.log( 'importHvml was called' );

      // this.hvmlImported = ( this.hvmlImported || new Promise( this._resolveHvml.bind( this ) ) );
      this.hvmlImported = ( new Promise( this._resolveHvml.bind( this ) ) );
      this.hvmlImported
        .then( ( response ) => {
          // console.log( 'HVML has been imported; selecting hvml:video elements from: ', response );
          let nodes = this.select( '//hvml:video', response );
          return nodes;
        } )
        .then( this._appendEntries.bind( this ) )
        .then( () => {
          this.setAttribute( 'loaded', 'loaded' );
        } )
        .catch( ( error ) => {
          console.warn( 'HVML Import failed: ', error );
          delete this.hvmlImported;
        } )
      ;
    }
  }
};

export default HVMLAwareElement;
